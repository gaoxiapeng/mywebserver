单例模式：一个类只有一个实例，并提供一个全局访问点。单例模式就是将构造函数和析构函数放到private中（私有化构造函数），使得外部无法访问构造函数，那么自然无法手动实例化对象了。且删除了拷贝构造和幅值操作

## 实例化一个对象实际上分两步：
    - 内存分配
    - 调用构造函数


## 阻塞队列（BlockDeque）代码总结

该阻塞队列基于 `std::deque` 实现，利用互斥锁和条件变量来保证多线程环境下的数据安全访问。其核心逻辑是通过 **生产者-消费者模型** 来协调数据的存取，确保线程间同步与资源互斥。

在设计上，队列提供了固定容量，生产者在队列已满时会被阻塞，消费者在队列为空时同样会被阻塞。条件变量在合适的时机被唤醒，从而让线程继续执行，避免了资源竞争和忙等。  
关闭队列时会清空数据，并唤醒所有等待中的线程，使得生产者和消费者可以感知队列的结束状态，从而安全退出。

整体流程可以总结为：
- **生产者线程** 调用 `push_back` 或 `push_front` 插入数据，若队列已满则等待，直到有消费者取走数据。
- **消费者线程** 调用 `pop` 获取数据，若队列为空则等待，直到有生产者插入数据。
- **互斥锁** 保证队列操作的原子性，**条件变量** 保证线程间的同步。
- **关闭操作** 则负责中止队列运行，唤醒所有阻塞线程，确保程序能够正确收尾。

该实现体现了阻塞队列在多线程环境下的典型应用：在固定容量限制下通过同步机制实现线程安全的生产与消费，保证了数据处理的有序性与一致性。

# C++继承、多态

## 多态（Polymorphism）

在C++中，多态是指通过基类的指针或引用调用虚函数时，能够根据实际对象类型执行不同的函数实现。这是面向对象编程的核心特性之一，主要通过`virtual`关键字实现。

多态分为两种：
- 编译时多态（静态绑定）：通过函数重载和模板实现
- 运行时多态（动态绑定）：通过虚函数实现

## 虚函数（Virtual Function）

虚函数通过在基类中使用`virtual`关键字声明，允许派生类重写该函数：
```
class Base() {
public:
    virtual void show() {
        cout << "Base show" << endl;
    }
    void say() {
        cout << 1 << endl;
    }
};
```
```
class Derived() : public Base{   // 继承
public:
    void show() {
        cout << "Derived show" << endl;
    }
    void say() {
        cout << 2 << endl;
    }
};
```
> **当通过基类指针调用虚函数时，实际调用的是对象实际类型的函数版本：**
```
Base* b = new Derived();   // 基类指针指向派生类对象
b->show(); // 调用Derived::show()
b->say();  // 调用Base::say()
```

## 纯虚函数（Pure Virtual Function）

纯虚函数是在基类中声明但没有实现的虚函数，使用`= 0`语法：
```
class AbstractBase {
public:
virtual void mustImplement() = 0;
};
```
包含纯虚函数的类称为抽象类，不能实例化。派生类必须实现所有纯虚函数才能实例化。

## 虚析构函数（Virtual Destructor）

虚析构函数确保通过基类指针删除派生类对象时，能正确调用派生类的析构函数：
```
class Base {
public:
virtual ~Base() {} // 虚析构函数
};
```
**如果没有虚析构函数，通过基类指针删除派生类对象会导致只调用基类析构函数，而派生类析构函数不被调用，可能造成内存泄漏。**

## 纯虚析构函数（Pure Virtual Destructor）

纯虚析构函数是一种特殊的纯虚函数，它使类成为抽象类，但必须提供实现：

```
class AbstractBase {
public:
virtual ~AbstractBase() = 0;
};
AbstractBase::~AbstractBase() {} // 必须提供实现
```

纯虚析构函数主要用于：
1. 使类成为抽象类
2. 强制派生类实现自己的析构函数
3. 仍然保证析构链的正常执行

## 总结

1. 多态通过虚函数实现运行时动态绑定
2. 纯虚函数定义接口规范，强制派生类实现
3. 虚析构函数确保对象完整销毁
4. 纯虚析构函数使类抽象化同时保证析构安全


![Alt text](image.png)