单例模式：一个类只有一个实例，并提供一个全局访问点。单例模式就是将构造函数和析构函数放到private中（私有化构造函数），使得外部无法访问构造函数，那么自然无法手动实例化对象了。且删除了拷贝构造和幅值操作

## 实例化一个对象实际上分两步：
    - 内存分配
    - 调用构造函数


# 阻塞队列（BlockDeque）代码总结

该阻塞队列基于 `std::deque` 实现，利用互斥锁和条件变量来保证多线程环境下的数据安全访问。其核心逻辑是通过 **生产者-消费者模型** 来协调数据的存取，确保线程间同步与资源互斥。

在设计上，队列提供了固定容量，生产者在队列已满时会被阻塞，消费者在队列为空时同样会被阻塞。条件变量在合适的时机被唤醒，从而让线程继续执行，避免了资源竞争和忙等。  
关闭队列时会清空数据，并唤醒所有等待中的线程，使得生产者和消费者可以感知队列的结束状态，从而安全退出。

整体流程可以总结为：
- **生产者线程** 调用 `push_back` 或 `push_front` 插入数据，若队列已满则等待，直到有消费者取走数据。
- **消费者线程** 调用 `pop` 获取数据，若队列为空则等待，直到有生产者插入数据。
- **互斥锁** 保证队列操作的原子性，**条件变量** 保证线程间的同步。
- **关闭操作** 则负责中止队列运行，唤醒所有阻塞线程，确保程序能够正确收尾。

该实现体现了阻塞队列在多线程环境下的典型应用：在固定容量限制下通过同步机制实现线程安全的生产与消费，保证了数据处理的有序性与一致性。
